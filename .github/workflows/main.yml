name: Deploy MERN App using GitHub Actions

on:
  workflow_dispatch:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and Push Backend Image
        run: |
          docker build -t ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/semicon-backend:latest ./backend
          docker push ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/semicon-backend:latest

      - name: Build and Push Frontend Image
        run: |
          docker build \
             -t ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/frontend:latest \
              frontend \
            --build-arg ENVIRONMENT=development
          docker push ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/frontend:latest

      - name: Deploy to EC2
        uses: appleboy/ssh-action@v0.1.7
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          script: |
            PROJECT_DIR="/home/ubuntu/test-app"
            ECR_URL="${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com"

            echo "üîç Checking if project directory exists..."
            if [ ! -d "$PROJECT_DIR" ]; then
              echo "üì¶ First-time setup: Installing dependencies and cloning repository..."
              sudo apt update -y
              sudo apt install -y ca-certificates curl gnupg lsb-release awscli git apache2

              echo "üìÇ Cloning project..."
              git clone https://github.com/GangaLakshmi2002/test-app.git $PROJECT_DIR
            else
              echo "‚úÖ Project already exists, pulling latest changes"
              cd $PROJECT_DIR && git pull origin main
            fi
           
            echo "üîπ Checking Apache2 installation..."
            if ! command -v apache2 &> /dev/null; then
              echo "üì¶ Installing Apache2..."
              sudo apt update -y
              sudo apt install -y apache2
              echo "‚úÖ Apache2 installed successfully"
            else
              echo "‚úÖ Apache2 already installed"
            fi


            echo "üîπ Checking Apache2 installation..."
            if ! command -v apache2 &> /dev/null; then
               echo "üì¶ Installing Apache2..."
               sudo apt update -y
               sudo apt install -y apache2
               echo "‚úÖ Apache2 installed successfully"
            else
               echo "‚úÖ Apache2 already installed"
            fi

            # --- Enable Required Modules ---
            echo "üîπ Ensuring Apache proxy modules are enabled..."
            sudo a2enmod proxy proxy_http headers rewrite >/dev/null 2>&1 || true

            # --- Write Valid VirtualHost File ---
            VHOST_FILE="/etc/apache2/sites-available/000-default.conf"

            echo "üîπ Configuring Apache VirtualHost..."
            sudo tee $VHOST_FILE >/dev/null <<EOF
            <VirtualHost *:80>
             ServerName ${HOSTNAME}

            # Keep host header for backend
            ProxyPreserveHost On

            # Backend API
            ProxyPass /api http://localhost:5000/
            ProxyPassReverse /api http://localhost:5000/

            # Frontend (served from Docker or static files)
            ProxyPass / http://localhost:3000/
            ProxyPassReverse / http://localhost:3000/

            ErrorLog \${APACHE_LOG_DIR}/error.log
            CustomLog \${APACHE_LOG_DIR}/access.log combined
            </VirtualHost>
            EOF

            # --- Validate Configuration ---
            echo "üîç Validating Apache configuration..."
            if sudo apache2ctl configtest 2>&1 | grep -q "Syntax OK"; then
               echo "‚úÖ Apache configuration is valid"
            else
               echo "‚ùå Apache configuration invalid:"
               sudo apache2ctl configtest
               exit 1
            fi

            # --- Restart Apache ---
            echo "üîÅ Restarting Apache service..."
            sudo systemctl daemon-reload
            sudo systemctl restart apache2

            if sudo systemctl is-active --quiet apache2; then
              echo "‚úÖ Apache is running and configured properly"

            else
              echo "‚ùå Apache failed to start, showing last 20 log lines..."
              sudo journalctl -xeu apache2.service --no-pager | tail -20
              exit 1
            fi

            echo "üìä Enabled Apache modules:"
            apache2ctl -M | grep proxy || echo "‚ö†Ô∏è Proxy modules not found"


        
            # Verify restart was successful
            if sudo systemctl is-active --quiet apache2; then
                echo "‚úÖ Apache2 restarted successfully"
            else
              echo "‚ùå Apache2 failed to restart. Checking logs..."
              sudo journalctl -xeu apache2.service --no-pager | tail -20
              exit 1
            fi

            # ‚úÖ Final verification
              echo "üîç Final Apache status check..."
              sudo systemctl status apache2 --no-pager || true

            # ‚úÖ Create project root .env file (for docker-compose and shared config)
            if [ ! -f "$PROJECT_DIR/.env" ]; then
               echo "üìù Creating project root .env file (first time)..."
               cat > $PROJECT_DIR/.env <<'ENVEOF'
                   # AWS Configuration
                     AWS_ACCOUNT_ID=${{ secrets.AWS_ACCOUNT_ID }}
                     AWS_REGION=${{ secrets.AWS_REGION }}
                     IMAGE_TAG=latest

                   # Database credentials for PostgreSQL container
                     POSTGRES_USER=taskmanager
                     POSTGRES_PASSWORD=taskmanager
                     POSTGRES_DB=taskmanager

                   # Database connection for backend application
                     DATABASE_HOST=127.0.0.1
                     DATABASE_PORT=5432
                     DATABASE_USER=postgres
                     DATABASE_PASSWORD=postgres111
                     DATABASE_NAME=tasks
                ENVEOF
                echo "‚úÖ Project root .env file created"
            else
                echo "‚úÖ Project root .env already exists, skipping creation."
            fi
            
            if [ ! -f "$PROJECT_DIR/frontend/.env" ]; then
              echo "üìù Creating frontend .env file (first time)..."
              cat > "$PROJECT_DIR/frontend/.env" <<'ENVEOF'
            NEXT_PUBLIC_API_BASE_URL=${{ secrets.NEXT_PUBLIC_API_BASE_URL }}
            NODE_ENV=development
            ENVEOF
            else
              echo "‚úÖ Frontend .env already exists, skipping creation."
            fi

            if [ ! -f "$PROJECT_DIR/backend/.env" ]; then
              echo "üìù Creating backend .env (first time or empty)..."
              cat > "$PROJECT_DIR/backend/.env" <<EOF
            NODE_ENV=production
            JWT_SECRET=${{ secrets.JWT_SECRET }}
            PORT=5000
            EOF
              chmod 600 "$PROJECT_DIR/backend/.env" || true
              cp "$PROJECT_DIR/backend/.env" "$PROJECT_DIR/backend/.env.production"
              echo "‚úÖ Wrote: $PROJECT_DIR/backend/.env and .env.production"

            else
              SIZE=$(wc -c < "$PROJECT_DIR/backend/.env" 2>/dev/null || echo 0)
              echo "‚úÖ Backend .env already exists, skipping creation."
            fi

            

            echo "üîπ Checking & installing Docker if not present..."
            if ! command -v docker &> /dev/null; then
              echo "Installing Docker..."
              sudo apt-get update -y
              sudo apt-get install -y ca-certificates curl gnupg lsb-release
              sudo mkdir -p /etc/apt/keyrings
              curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
              echo \
                "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] \
                https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | \
                sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
              sudo apt-get update -y
              sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
              sudo systemctl enable docker
              sudo systemctl start docker
            else
              echo "‚úÖ Docker already installed."
            fi

            echo "üîπ Checking Docker Compose plugin..."
            if ! docker-compose version &> /dev/null; then
              echo "Installing Docker Compose plugin..."
              sudo curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose
            else
              echo "‚úÖ Docker Compose already available."
            fi

            if ! command -v aws >/dev/null 2>&1; then
              echo "Installing AWS CLI v2..."
              sudo apt-get update -y && sudo apt-get install -y unzip curl
              ARCH=$(uname -m)
              if [ "$ARCH" = "x86_64" ]; then AWSCLIZIP="awscli-exe-linux-x86_64.zip"; else AWSCLIZIP="awscli-exe-linux-aarch64.zip"; fi
              curl -fsSL "https://awscli.amazonaws.com/${AWSCLIZIP}" -o "awscliv2.zip"
              unzip -q awscliv2.zip
              sudo ./aws/install
              rm -rf aws awscliv2.zip
            fi
            echo "AWS CLI: $(aws --version)"

             # ---------- Configure AWS credentials (from GitHub Secrets) ----------
            echo "üîê Configuring AWS credentials..."
            mkdir -p ~/.aws

            cat > ~/.aws/credentials <<EOF
            [default]
            aws_access_key_id=${{ secrets.AWS_ACCESS_KEY_ID }}
            aws_secret_access_key=${{ secrets.AWS_SECRET_ACCESS_KEY }}
            EOF

            cat > ~/.aws/config <<EOF
            [default]
            region=${{ secrets.AWS_REGION }}
            output=json
            EOF

            chmod 600 ~/.aws/credentials ~/.aws/config
            echo "‚úÖ AWS CLI configured successfully"


            echo "üîë Logging in to ECR..."
            aws ecr get-login-password --region ${{ secrets.AWS_REGION }} | sudo docker login --username AWS --password-stdin $ECR_URL

            # # ----- ECR auth for Docker (use sudo if docker-compose uses sudo) -----
            # if aws ecr get-login-password --region ${{ secrets.AWS_REGION }} | sudo docker login --username AWS --password-stdin "$ECR_URL"; then
            #   echo "‚úÖ ECR login OK: $ECR_URL"
            # else
            #   echo "‚ùå ECR login failed: $ECR_URL" && exit 1
            # fi

           

            echo "üßπ Starting pre-deployment cleanup..."
            cd $PROJECT_DIR

            echo "üì¶ Stopping and removing existing containers (preserving volumes)..."
            if sudo docker-compose ps -q 2>/dev/null | grep -q .; then
              echo "üîç Found running containers. Listing them:"
              sudo docker-compose ps
              echo "üõë Stopping containers..."
              sudo docker-compose down 2>&1 | tee /tmp/docker-down.log
              if [ ${PIPESTATUS[0]} -eq 0 ]; then
                echo "‚úÖ Containers stopped successfully"
              else
                echo "‚ö†Ô∏è Warning during container stop (check logs):"
                cat /tmp/docker-down.log
              fi
            else
              echo "‚úÖ No existing containers found, skipping docker-compose down"
            fi

            echo "üóëÔ∏è Removing dangling images and stopped containers..."
            PRUNE_OUTPUT=$(sudo docker system prune -f 2>&1)
            echo "$PRUNE_OUTPUT"
            RECLAIMED=$(echo "$PRUNE_OUTPUT" | grep -oP 'Total reclaimed space: \K.*' || echo "0B")
            echo "üìä Cleanup stats: Reclaimed $RECLAIMED of disk space"

            echo "üîç Verifying data volumes are preserved..."
            VOLUME_COUNT=$(sudo docker volume ls -q | wc -l)
            echo "üì¶ Data volumes preserved: $VOLUME_COUNT volume(s) remain"

            echo "üìä Current Docker state before deployment:"
            echo "  Images: $(sudo docker images -q | wc -l)"
            echo "  Containers: $(sudo docker ps -a -q | wc -l)"
            echo "  Networks: $(sudo docker network ls -q | wc -l)"

            echo "üöÄ Deploying containers..."
            cd $PROJECT_DIR
            sudo DOCKER_CONFIG=/home/ubuntu/.docker docker-compose pull
            sudo DOCKER_CONFIG=/home/ubuntu/.docker docker-compose up -d --build

            echo "üìä Post-deployment Docker state:"
            sudo docker-compose ps
            echo "  Running containers: $(sudo docker ps -q | wc -l)"

            echo "üßπ Final cleanup of unused Docker data..."
            sudo docker system prune -f

            echo "‚úÖ Deployment complete!"
