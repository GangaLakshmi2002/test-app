name: Deploy MERN App using GitHub Actions

on:
  workflow_dispatch:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and Push Backend Image
        run: |
          docker build -t ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/semicon-backend:latest ./backend
          docker push ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/semicon-backend:latest

      - name: Build and Push Frontend Image
        run: |
          docker build \
             -t ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/frontend:latest \
              frontend \
            --build-arg ENVIRONMENT=development
          docker push ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/frontend:latest

      - name: Deploy to EC2
        uses: appleboy/ssh-action@v0.1.7
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          script: |
            PROJECT_DIR="/home/ubuntu/test-app"
            ECR_URL="${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com"

            echo "üîç Checking if project directory exists..."
            if [ ! -d "$PROJECT_DIR" ]; then
              echo "üì¶ First-time setup: Installing dependencies and cloning repository..."
              sudo apt update -y
              sudo apt install -y ca-certificates curl gnupg lsb-release awscli git apache2

              echo "üìÇ Cloning project..."
              git clone https://github.com/GangaLakshmi2002/test-app.git $PROJECT_DIR
            else
              echo "‚úÖ Project already exists, pulling latest changes"
              cd $PROJECT_DIR && git pull origin main
            fi
           
            echo "üîπ Checking Apache2 installation..."
            if ! command -v apache2 &> /dev/null; then
              echo "üì¶ Installing Apache2..."
              sudo apt update -y
              sudo apt install -y apache2
              echo "‚úÖ Apache2 installed successfully"
            else
              echo "‚úÖ Apache2 already installed"
            fi


            echo "üîπ Checking Apache2 installation..."
            if ! command -v apache2 &> /dev/null; then
               echo "üì¶ Installing Apache2..."
               sudo apt update -y
               sudo apt install -y apache2
               echo "‚úÖ Apache2 installed successfully"
            else
               echo "‚úÖ Apache2 already installed"
            fi

            # --- Enable Required Modules ---
            echo "üîπ Ensuring Apache proxy modules are enabled..."
            sudo a2enmod proxy proxy_http headers rewrite >/dev/null 2>&1 || true

            # --- Write Valid VirtualHost File ---
            VHOST_FILE="/etc/apache2/sites-available/000-default.conf"

            echo "üîπ Configuring Apache VirtualHost..."
            sudo tee $VHOST_FILE >/dev/null <<EOF
            <VirtualHost *:80>
             ServerName ${HOSTNAME}

            # Keep host header for backend
            ProxyPreserveHost On

            # Backend API
            ProxyPass /api http://localhost:5000/
            ProxyPassReverse /api http://localhost:5000/

            # Frontend (served from Docker or static files)
            ProxyPass / http://localhost:3000/
            ProxyPassReverse / http://localhost:3000/

            ErrorLog \${APACHE_LOG_DIR}/error.log
            CustomLog \${APACHE_LOG_DIR}/access.log combined
            </VirtualHost>
            EOF

            # --- Validate Configuration ---
            echo "üîç Validating Apache configuration..."
            if sudo apache2ctl configtest 2>&1 | grep -q "Syntax OK"; then
               echo "‚úÖ Apache configuration is valid"
            else
               echo "‚ùå Apache configuration invalid:"
               sudo apache2ctl configtest
               exit 1
            fi

            # --- Restart Apache ---
            echo "üîÅ Restarting Apache service..."
            sudo systemctl daemon-reload
            sudo systemctl restart apache2

            if sudo systemctl is-active --quiet apache2; then
              echo "‚úÖ Apache is running and configured properly"
            else
              echo "‚ùå Apache failed to start, showing last 20 log lines..."
              sudo journalctl -xeu apache2.service --no-pager | tail -20
              exit 1
            fi

            echo "üìä Enabled Apache modules:"
            apache2ctl -M | grep proxy || echo "‚ö†Ô∏è Proxy modules not found"



            # # NEW: Conditional Apache Module Configuration
            # echo "üîπ Checking Apache proxy modules..."
            # PROXY_ENABLED=$(apache2ctl -M 2>/dev/null | grep -c "proxy_module" || echo "0")
            # PROXY_HTTP_ENABLED=$(apache2ctl -M 2>/dev/null | grep -c "proxy_http_module" || echo "0")

            # if [ "$PROXY_ENABLED" -eq 0 ] || [ "$PROXY_HTTP_ENABLED" -eq 0 ]; then
            #   echo "‚öôÔ∏è Enabling Apache proxy modules..."
            #   sudo a2enmod proxy proxy_http
            #   echo "üîÅ Reloading Apache to activate proxy modules..."
            #   sudo systemctl reload apache2 || true
            #   MODULES_CHANGED=true
            #   echo "‚úÖ Proxy modules enabled and reloaded"
            # else
            #   echo "‚úÖ Proxy modules already enabled"
            #    MODULES_CHANGED=false
            # fi


            # # NEW: Conditional VirtualHost Configuration
            # echo "üîπ Checking Apache VirtualHost configuration..."
            # VHOST_FILE="/etc/apache2/sites-available/000-default.conf"
            
            # if ! grep -q "ProxyPass /api" "$VHOST_FILE" 2>/dev/null; then
            #   echo "‚öôÔ∏è Configuring Apache VirtualHost for reverse proxy..."
            #   sudo bash -c "cat > $VHOST_FILE <<'EOF'
            #   <VirtualHost *:80>
            #   ServerName ${{ secrets.SERVER_HOST }}
            #   ProxyPreserveHost On
  
            #   # Backend API proxy
            #   ProxyPass /api http://localhost:5000/
            #   ProxyPassReverse /api http://localhost:5000/
  
            #   # Frontend proxy
            #   ProxyPass / http://localhost:80/
            #   ProxyPassReverse / http://localhost:80/
  
            #   ErrorLog \${APACHE_LOG_DIR}/error.log
            #   CustomLog \${APACHE_LOG_DIR}/access.log combined
            #   </VirtualHost>
            #   EOF"

            #   VHOST_CHANGED=true
            #   echo "‚úÖ VirtualHost configuration updated"
            # else
            #   echo "‚úÖ VirtualHost already configured with proxy rules"
            #   VHOST_CHANGED=false
            # fi

            # # ‚úÖ Step 4: Validate configuration BEFORE restarting
            # echo "üîç Validating Apache2 configuration..."
            # if sudo apache2ctl configtest 2>&1 | grep -q "Syntax OK"; then
            #    echo "‚úÖ Apache configuration is valid"
            # else
            #    echo "‚ùå Apache configuration has errors:"
            #    sudo apache2ctl configtest
            #    echo "‚ö†Ô∏è Attempting to fix by reloading modules..."
            #    sudo systemctl reload apache2
            # fi

            #  # ‚úÖ Step 5: Start/Restart Apache only if needed
            #  echo "üîπ Checking Apache2 service status..."

            # if ! sudo systemctl is-active --quiet apache2; then
            #     echo "üöÄ Starting Apache2 service..."
            #     sudo systemctl start apache2
            #     sudo systemctl enable apache2
            #     echo "‚úÖ Apache2 service started and enabled"
            # elif [ "$MODULES_CHANGED" = true ] || [ "$VHOST_CHANGED" = true ]; then
            #     echo "üîÑ Restarting Apache2 to apply changes..."
            #     sudo systemctl restart apache2
        
              # Verify restart was successful
                if sudo systemctl is-active --quiet apache2; then
                   echo "‚úÖ Apache2 restarted successfully"
                else
                   echo "‚ùå Apache2 failed to restart. Checking logs..."
                   sudo journalctl -xeu apache2.service --no-pager | tail -20
                   exit 1
                fi
            else
               echo "‚úÖ Apache2 is running, no changes needed"
            fi

            # ‚úÖ Final verification
              echo "üîç Final Apache status check..."
              sudo systemctl status apache2 --no-pager || true
              echo "üìä Enabled Apache modules:"
              apache2ctl -M | grep proxy || echo "‚ö†Ô∏è No proxy modules found"



            if [ ! -f "$PROJECT_DIR/backend/.env" ]; then
              echo "üìù Creating backend .env file (first time)..."
              cat > $PROJECT_DIR/backend/.env <<'ENVEOF'
            NODE_ENV=production
            JWT_SECRET=${{ secrets.JWT_SECRET }}
            PORT=5000
            ENVEOF
            else
              echo "‚úÖ Backend .env already exists, skipping creation."
            fi

            if [ ! -f "$PROJECT_DIR/frontend/.env" ]; then
              echo "üìù Creating frontend .env file (first time)..."
              cat > $PROJECT_DIR/frontend/.env <<'ENVEOF'
            NEXT_PUBLIC_API_BASE_URL=${{ secrets.NEXT_PUBLIC_API_BASE_URL }}
            NODE_ENV=development
            ENVEOF
            else
              echo "‚úÖ Frontend .env already exists, skipping creation."
            fi

            echo "üîπ Checking & installing Docker if not present..."
            if ! command -v docker &> /dev/null; then
              echo "Installing Docker..."
              sudo apt-get update -y
              sudo apt-get install -y ca-certificates curl gnupg lsb-release
              sudo mkdir -p /etc/apt/keyrings
              curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
              echo \
                "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] \
                https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | \
                sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
              sudo apt-get update -y
              sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
              sudo systemctl enable docker
              sudo systemctl start docker
            else
              echo "‚úÖ Docker already installed."
            fi

            echo "üîπ Checking Docker Compose plugin..."
            if ! docker-compose version &> /dev/null; then
              echo "Installing Docker Compose plugin..."
              sudo curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose
            else
              echo "‚úÖ Docker Compose already available."
            fi

            echo "üîë Logging in to ECR..."
            aws ecr get-login-password --region ${{ secrets.AWS_REGION }} | docker login --username AWS --password-stdin $ECR_URL

            echo "üßπ Starting pre-deployment cleanup..."
            cd $PROJECT_DIR

            echo "üì¶ Stopping and removing existing containers (preserving volumes)..."
            if sudo docker-compose ps -q 2>/dev/null | grep -q .; then
              echo "üîç Found running containers. Listing them:"
              sudo docker-compose ps
              echo "üõë Stopping containers..."
              sudo docker-compose down 2>&1 | tee /tmp/docker-down.log
              if [ ${PIPESTATUS[0]} -eq 0 ]; then
                echo "‚úÖ Containers stopped successfully"
              else
                echo "‚ö†Ô∏è Warning during container stop (check logs):"
                cat /tmp/docker-down.log
              fi
            else
              echo "‚úÖ No existing containers found, skipping docker-compose down"
            fi

            echo "üóëÔ∏è Removing dangling images and stopped containers..."
            PRUNE_OUTPUT=$(sudo docker system prune -f 2>&1)
            echo "$PRUNE_OUTPUT"
            RECLAIMED=$(echo "$PRUNE_OUTPUT" | grep -oP 'Total reclaimed space: \K.*' || echo "0B")
            echo "üìä Cleanup stats: Reclaimed $RECLAIMED of disk space"

            echo "üîç Verifying data volumes are preserved..."
            VOLUME_COUNT=$(sudo docker volume ls -q | wc -l)
            echo "üì¶ Data volumes preserved: $VOLUME_COUNT volume(s) remain"

            echo "üìä Current Docker state before deployment:"
            echo "  Images: $(sudo docker images -q | wc -l)"
            echo "  Containers: $(sudo docker ps -a -q | wc -l)"
            echo "  Networks: $(sudo docker network ls -q | wc -l)"

            echo "üöÄ Deploying containers..."
            cd $PROJECT_DIR
            sudo DOCKER_CONFIG=/home/ubuntu/.docker docker-compose pull
            sudo DOCKER_CONFIG=/home/ubuntu/.docker docker-compose up -d --build

            echo "üìä Post-deployment Docker state:"
            sudo docker-compose ps
            echo "  Running containers: $(sudo docker ps -q | wc -l)"

            echo "üßπ Final cleanup of unused Docker data..."
            sudo docker system prune -f

            echo "‚úÖ Deployment complete!"
